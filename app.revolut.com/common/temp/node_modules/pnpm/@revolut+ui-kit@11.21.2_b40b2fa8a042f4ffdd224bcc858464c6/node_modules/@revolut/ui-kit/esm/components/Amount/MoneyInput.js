/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React, { forwardRef, useCallback, useMemo, useState } from 'react';
import { useRifm } from 'rifm';
import { changeNumberFormatCurrencySymbol, filterNumberFormatCurrency, getNumberFractionDigits, joinNumberFormatParts } from "../../utils";
import { KeyboardEventKey } from "../../constants";
import { useControlled, useCurrency, useLocale } from "../../hooks";
import { InputBase } from "../InputBase";
import { AmountInputMoneyType } from "./constants";
var DELIMITER = '.';
export var MoneyInput = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var type = _ref.type,
      controlledValue = _ref.value,
      _ref$defaultValue = _ref.defaultValue,
      defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue,
      onChange = _ref.onChange,
      placeholder = _ref.placeholder,
      currency = _ref.currency,
      _ref$showSign = _ref.showSign,
      showSign = _ref$showSign === void 0 ? false : _ref$showSign,
      _ref$showCurrency = _ref.showCurrency,
      showCurrency = _ref$showCurrency === void 0 ? true : _ref$showCurrency,
      _ref$negative = _ref.negative,
      negative = _ref$negative === void 0 ? false : _ref$negative,
      onKeyPress = _ref.onKeyPress,
      inputProps = _objectWithoutPropertiesLoose(_ref, ["type", "value", "defaultValue", "onChange", "placeholder", "currency", "showSign", "showCurrency", "negative", "onKeyPress"]);

  var locale = useLocale();
  var delimiters = useDelimiters(locale);
  var parseNumber = useParseNumber(_extends({}, delimiters, {
    negative: negative
  }));
  var customCurrencyDefinition = useCurrency(currency);
  var formatter = useMemo(function () {
    return getFormatter({
      locale: locale,
      currency: currency,
      showSign: showSign,
      maximumFractionDigits: customCurrencyDefinition == null ? void 0 : customCurrencyDefinition.fractionalPart
    });
  }, [locale, currency, showSign, customCurrencyDefinition]);
  var fractionalPart = useMemo(function () {
    var _customCurrencyDefini;

    return (_customCurrencyDefini = customCurrencyDefinition == null ? void 0 : customCurrencyDefinition.fractionalPart) != null ? _customCurrencyDefini : getNumberFractionDigits(locale, currency);
  }, [locale, currency, customCurrencyDefinition]);

  var _useControlled = useControlled({
    defaultValue: defaultValue,
    value: controlledValue,
    onChange: onChange
  }),
      value = _useControlled[0],
      setValueArgument = _useControlled[1];

  var _useState = useState(null),
      decimalPart = _useState[0],
      setDecimalPart = _useState[1];

  var setValue = useCallback(function (nextValue) {
    setValueArgument(type === AmountInputMoneyType.MONEY_FRACTIONAL && nextValue ? Number(nextValue.toFixed(fractionalPart).replace(DELIMITER, '')) : nextValue);
  }, [setValueArgument, type, fractionalPart]);
  var accept = useMemo(function () {
    return new RegExp("[\\d" + delimiters.decimal + "]", 'g');
  }, [delimiters.decimal]);
  var formatValue = useCallback(function (nextValue, decimalPartArg) {
    if (decimalPartArg === void 0) {
      decimalPartArg = null;
    }

    if (nextValue == null) {
      return '';
    }

    var targetValue = negative && nextValue > 0 ? -nextValue : nextValue;
    var currencySymbol = customCurrencyDefinition == null ? void 0 : customCurrencyDefinition.symbol;

    if (decimalPartArg === null) {
      return formatValueWithFormatter({
        formatter: formatter,
        value: targetValue,
        showCurrency: showCurrency,
        currencySymbol: currencySymbol
      });
    }

    if (decimalPartArg === 0) {
      var parts = formatter.formatToParts(targetValue);

      if (currencySymbol) {
        parts = changeNumberFormatCurrencySymbol(parts, currencySymbol);
      }

      var lastIntegerPart = [].concat(parts).reverse().find(function (part) {
        return part.type === 'integer';
      });

      if (lastIntegerPart) {
        parts.splice(parts.indexOf(lastIntegerPart) + 1, 0, {
          type: 'decimal',
          value: delimiters.decimal
        });
      }

      if (!showCurrency) {
        parts = filterNumberFormatCurrency(parts);
      }

      return joinNumberFormatParts(parts);
    }

    return formatValueWithFormatter({
      formatter: getFormatter({
        locale: locale,
        currency: currency,
        minimumFractionDigits: decimalPartArg,
        maximumFractionDigits: customCurrencyDefinition == null ? void 0 : customCurrencyDefinition.fractionalPart,
        showSign: showSign
      }),
      value: targetValue,
      showCurrency: showCurrency,
      currencySymbol: currencySymbol
    });
  }, [formatter, delimiters.decimal, currency, locale, showSign, showCurrency, negative, customCurrencyDefinition]);
  var rifm = useRifm({
    accept: accept,
    value: formatValue(type === AmountInputMoneyType.MONEY_FRACTIONAL && value ? value / Math.pow(10, fractionalPart) : value, decimalPart),
    format: function format(next) {
      var nextNumber = parseNumber(next);
      return formatValue(nextNumber, getDecimalPart(next, delimiters.decimal, fractionalPart));
    },
    onChange: function onChange(next) {
      setDecimalPart(getDecimalPart(next, delimiters.decimal, fractionalPart));
      var nextNumber = parseNumber(next);
      setValue(nextNumber);
    }
  });
  var keyPressHandler = useCallback(function (event) {
    onKeyPress == null ? void 0 : onKeyPress(event);

    if (event.key === KeyboardEventKey.PERIOD && delimiters.decimal !== KeyboardEventKey.PERIOD) {
      var caretPosition = event.currentTarget.selectionStart;

      if (caretPosition) {
        event.currentTarget.value = event.currentTarget.value.substr(0, caretPosition) + delimiters.decimal + event.currentTarget.value.substr(caretPosition, event.currentTarget.value.length);
        event.currentTarget.selectionStart = caretPosition + 1;
        event.currentTarget.selectionEnd = event.currentTarget.selectionStart;
      }
    }
  }, [delimiters.decimal, onKeyPress]);
  return /*#__PURE__*/React.createElement(InputBase, _extends({
    ref: ref,
    placeholder: placeholder != null ? placeholder : formatValue(0),
    inputMode: "decimal"
  }, inputProps, {
    onKeyPress: keyPressHandler,
    use: "input"
  }, rifm));
});

var getFormatter = function getFormatter(_ref2) {
  var locale = _ref2.locale,
      currency = _ref2.currency,
      showSign = _ref2.showSign,
      _ref2$minimumFraction = _ref2.minimumFractionDigits,
      minimumFractionDigits = _ref2$minimumFraction === void 0 ? 0 : _ref2$minimumFraction,
      maximumFractionDigits = _ref2.maximumFractionDigits;
  return Intl.NumberFormat(locale, currency ? {
    style: 'currency',
    currency: currency,
    currencyDisplay: 'narrowSymbol',
    minimumFractionDigits: minimumFractionDigits,
    maximumFractionDigits: maximumFractionDigits,
    signDisplay: showSign ? 'exceptZero' : undefined
  } : {
    minimumFractionDigits: minimumFractionDigits,
    maximumFractionDigits: maximumFractionDigits,
    signDisplay: showSign ? 'exceptZero' : undefined
  });
};

var formatValueWithFormatter = function formatValueWithFormatter(_ref3) {
  var formatter = _ref3.formatter,
      value = _ref3.value,
      showCurrency = _ref3.showCurrency,
      currencySymbol = _ref3.currencySymbol;
  var parts = formatter.formatToParts(value);

  if (!showCurrency) {
    parts = filterNumberFormatCurrency(parts);
  } else if (currencySymbol) {
    parts = changeNumberFormatCurrencySymbol(parts, currencySymbol);
  }

  return joinNumberFormatParts(parts);
};

var getDecimalPart = function getDecimalPart(next, decimal, maxFractionDigits) {
  var _next$slice$match$len, _next$slice$match;

  if (!next.includes(decimal)) {
    return null;
  }

  return Math.min((_next$slice$match$len = (_next$slice$match = next.slice(removeDuplicateDelimiters(next, decimal).lastIndexOf(decimal) + 1).match(/\d/g)) == null ? void 0 : _next$slice$match.length) != null ? _next$slice$match$len : 0, maxFractionDigits);
};

var removeDuplicateDelimiters = function removeDuplicateDelimiters(value, delimiter) {
  var firstDelimiterPosition = value.indexOf(delimiter);
  return firstDelimiterPosition >= 0 ? value.slice(0, firstDelimiterPosition + 1) + value.slice(firstDelimiterPosition + 1).replace(new RegExp("\\" + delimiter, 'g'), '') : value;
};

var useDelimiters = function useDelimiters(locale) {
  return useMemo(function () {
    var utilityFormatter = getFormatter({
      locale: locale
    });
    return {
      group: utilityFormatter.format(11111).replace(/1/g, ''),
      decimal: utilityFormatter.format(1.1).replace(/1/g, '')
    };
  }, [locale]);
};

var useParseNumber = function useParseNumber(_ref4) {
  var group = _ref4.group,
      decimal = _ref4.decimal,
      negative = _ref4.negative;
  return useCallback(function (value) {
    var reversedValue = value;

    if (group) {
      reversedValue = reversedValue.replace(new RegExp("\\" + group, 'g'), '');
    }

    if (decimal) {
      reversedValue = reversedValue.replace(new RegExp("\\" + decimal, 'g'), DELIMITER);
    }

    reversedValue = removeDuplicateDelimiters(reversedValue, DELIMITER);
    reversedValue = reversedValue.replace(new RegExp("[^\\d.," + (negative ? '' : '-') + "]", 'g'), '');

    if (reversedValue.trim() === '') {
      return null;
    }

    var numberValue = Number(reversedValue);
    return Number.isNaN(numberValue) ? null : numberValue;
  }, [group, decimal, negative]);
};