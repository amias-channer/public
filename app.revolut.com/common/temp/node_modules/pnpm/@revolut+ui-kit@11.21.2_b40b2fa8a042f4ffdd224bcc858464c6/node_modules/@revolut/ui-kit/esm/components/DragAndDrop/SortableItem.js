/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React, { useMemo } from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { DragType } from "./constants";
export function useSortableItem(_ref) {
  var type = _ref.type,
      options = _objectWithoutPropertiesLoose(_ref, ["type"]);

  var sortable = useSortable(options);
  var transform = CSS.Translate.toString(sortable.transform);
  var props = useMemo(function () {
    switch (type) {
      case DragType.SIDE_NAV_ITEM:
      case DragType.TAB:
        {
          var _sortable$transition;

          var _sortable$attributes = sortable.attributes,
              role = _sortable$attributes.role,
              attributes = _objectWithoutPropertiesLoose(_sortable$attributes, ["role"]);

          return _extends({
            style: {
              transform: transform,
              transition: (_sortable$transition = sortable.transition) != null ? _sortable$transition : undefined,
              opacity: sortable.isDragging ? 0 : undefined,
              userSelect: 'none',
              WebkitUserSelect: 'none',
              WebkitTouchCallout: 'none'
            },
            draggable: false,
            ref: sortable.setNodeRef
          }, attributes, sortable.listeners, sortable.isSorting ? {
            'aria-selected': false
          } : null, {
            // Prevent link drag in Firefox
            onDragStart: function onDragStart(e) {
              e.preventDefault();
            }
          });
        }

      default:
        return {};
    }
  }, [type, sortable.attributes, sortable.isDragging, sortable.isSorting, sortable.listeners, sortable.setNodeRef, sortable.transition, transform]);
  var defaultState = useMemo(function () {
    return {
      active: sortable.active,
      attributes: sortable.attributes,
      id: options.id,
      index: sortable.index,
      isDragging: sortable.isDragging,
      isSorting: sortable.isSorting,
      listeners: sortable.listeners,
      node: sortable.node,
      over: sortable.over,
      overIndex: sortable.overIndex,
      setNodeRef: sortable.setNodeRef,
      transform: sortable.transform,
      transition: sortable.transition
    };
  }, [options.id, sortable.active, sortable.attributes, sortable.index, sortable.isDragging, sortable.isSorting, sortable.listeners, sortable.node, sortable.over, sortable.overIndex, sortable.setNodeRef, sortable.transform, sortable.transition]);
  var propsState = useMemo(function () {
    return {
      active: sortable.active,
      id: options.id,
      index: sortable.index,
      isDragging: sortable.isDragging,
      isSorting: sortable.isSorting,
      over: sortable.over,
      props: props
    };
  }, [options.id, props, sortable.active, sortable.index, sortable.isDragging, sortable.isSorting, sortable.over]);

  switch (type) {
    case DragType.TAB:
    case DragType.SIDE_NAV_ITEM:
      return propsState;

    case DragType.APP_ICON:
    case DragType.DEFAULT:
      return defaultState;

    default:
      throw new Error('Type is required!');
  }
}
export function SortableItem(_ref2) {
  var children = _ref2.children,
      item = _ref2.item,
      options = _objectWithoutPropertiesLoose(_ref2, ["children", "item"]);

  var sortable = useSortableItem(options);
  var memoized = useMemo(function () {
    return children(sortable, item);
  }, [children, item, sortable]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, memoized);
}