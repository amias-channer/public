/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { Group } from '@visx/group';
import { ParentSizeModern } from '@visx/responsive';
import { Circle, Line } from '@visx/shape';
import { scaleLinear } from '@visx/scale';
import { Text } from '@visx/text';
import React, { useEffect, useMemo, useRef, useState } from 'react';
import { Color } from "../../constants";
import { useTheme } from "../../hooks";
import { themeColor } from "../../utils";
import { AXIS_RIGHT_MARGIN, CURRENT_POINT_LABEL_MARGIN, CURRENT_POINT_RADIUS, FAN_CHART_HEIGHT, FAN_CHART_MARGIN, LABEL_MIN_MARGIN, POINT_RADIUS } from "./constants";
import { GraphContainer } from "./styled";
import { FanChartCurrentValueLabel } from "./FanChartCurrentValueLabel";
export var FanChart = function FanChart(props) {
  return /*#__PURE__*/React.createElement(ParentSizeModern, null, function (_ref) {
    var width = _ref.width;
    return /*#__PURE__*/React.createElement(FanChartInner, _extends({
      width: width,
      height: FAN_CHART_HEIGHT
    }, props));
  });
};

var FanChartInner = function FanChartInner(_ref2) {
  var width = _ref2.width,
      height = _ref2.height,
      maxValue = _ref2.maxValue,
      minValue = _ref2.minValue,
      averageValue = _ref2.averageValue,
      currentValue = _ref2.currentValue,
      labelCurrent = _ref2.labelCurrent,
      labelMax = _ref2.labelMax,
      labelMin = _ref2.labelMin,
      labelAverage = _ref2.labelAverage,
      rest = _objectWithoutPropertiesLoose(_ref2, ["width", "height", "maxValue", "minValue", "averageValue", "currentValue", "labelCurrent", "labelMax", "labelMin", "labelAverage"]);

  var theme = useTheme();
  var whiteColor = themeColor(Color.WHITE)({
    theme: theme
  });
  var textColor = themeColor(Color.GREY_TONE_50)({
    theme: theme
  });
  var pointsColor = themeColor(Color.GREY_TONE_20)({
    theme: theme
  });
  var accentColor = themeColor(averageValue > currentValue ? Color.BLUE : Color.PINK)({
    theme: theme
  });
  var accentAreaColor = themeColor(averageValue > currentValue ? Color.BLUE_10 : Color.PINK_10)({
    theme: theme
  });
  var axisRightRef = useRef(null);

  var _useState = useState(0),
      axisRightWidth = _useState[0],
      setAxisRightWidth = _useState[1];

  useEffect(function () {
    if (axisRightRef.current) {
      var rect = axisRightRef.current.getBoundingClientRect();
      setAxisRightWidth(rect.width);
    }
  }, []);
  var graphWidth = width - FAN_CHART_MARGIN.left - FAN_CHART_MARGIN.right;
  var graphHeight = height - FAN_CHART_MARGIN.top - FAN_CHART_MARGIN.bottom;
  var max = Math.max(maxValue, currentValue);
  var min = Math.min(minValue, currentValue);
  var yScale = useMemo(function () {
    return scaleLinear({
      domain: [min, max],
      range: [graphHeight, 0]
    });
  }, [min, max, graphHeight]);
  var currentValuePoint = {
    x: 0,
    y: yScale(currentValue)
  };
  var currentValueLabelPoint = {
    x: 0,
    y: yScale(currentValue) + (Math.abs(currentValue - maxValue) > Math.abs(currentValue - minValue) ? -CURRENT_POINT_LABEL_MARGIN : CURRENT_POINT_LABEL_MARGIN)
  };
  var averageValuePoint = {
    x: graphWidth - (axisRightWidth + AXIS_RIGHT_MARGIN),
    y: yScale(averageValue)
  };
  var maxValuePoint = {
    x: graphWidth - (axisRightWidth + AXIS_RIGHT_MARGIN),
    y: yScale(maxValue)
  };
  var minValuePoint = {
    x: graphWidth - (axisRightWidth + AXIS_RIGHT_MARGIN),
    y: yScale(minValue)
  };
  var maxLabelMargin = averageValuePoint.y - maxValuePoint.y;
  var minLabelMargin = minValuePoint.y - averageValuePoint.y;
  var containerHeight = height;
  var groupTop = FAN_CHART_MARGIN.top;
  var maxLabelY = maxValuePoint.y;
  var minLabelY = minValuePoint.y;

  if (maxLabelMargin < LABEL_MIN_MARGIN) {
    maxLabelY -= LABEL_MIN_MARGIN - maxLabelMargin;
    containerHeight += LABEL_MIN_MARGIN - maxLabelMargin;
    groupTop += LABEL_MIN_MARGIN - maxLabelMargin;
  }

  if (minLabelMargin < LABEL_MIN_MARGIN) {
    minLabelY += LABEL_MIN_MARGIN - minLabelMargin;
    containerHeight += LABEL_MIN_MARGIN - minLabelMargin;
  }

  return /*#__PURE__*/React.createElement(GraphContainer, _extends({
    width: width,
    height: containerHeight
  }, rest), /*#__PURE__*/React.createElement(Group, {
    top: groupTop,
    left: FAN_CHART_MARGIN.left
  }, /*#__PURE__*/React.createElement("polygon", {
    points: currentValuePoint.x + "," + currentValuePoint.y + " " + averageValuePoint.x + "," + averageValuePoint.y + " " + averageValuePoint.x + "," + currentValuePoint.y,
    fill: accentAreaColor
  }), /*#__PURE__*/React.createElement(Line, {
    from: currentValuePoint,
    to: maxValuePoint,
    stroke: textColor,
    strokeDasharray: "2,3"
  }), /*#__PURE__*/React.createElement(Line, {
    from: currentValuePoint,
    to: averageValuePoint,
    stroke: accentColor,
    strokeDasharray: "2,3"
  }), /*#__PURE__*/React.createElement(Line, {
    from: currentValuePoint,
    to: minValuePoint,
    stroke: textColor,
    strokeDasharray: "2,3"
  }), /*#__PURE__*/React.createElement(Circle, {
    cx: currentValuePoint.x,
    cy: currentValuePoint.y,
    r: CURRENT_POINT_RADIUS,
    fill: accentColor
  }, /*#__PURE__*/React.createElement("animate", {
    attributeName: "fill-opacity",
    repeatCount: "indefinite",
    values: ".5; 0; 0",
    begin: "0s",
    dur: "1s"
  }), /*#__PURE__*/React.createElement("animate", {
    attributeName: "r",
    repeatCount: "indefinite",
    values: CURRENT_POINT_RADIUS + "; " + CURRENT_POINT_RADIUS * 4 + "; " + CURRENT_POINT_RADIUS * 4,
    begin: "0s",
    dur: "1s"
  })), /*#__PURE__*/React.createElement(Circle, {
    cx: currentValuePoint.x,
    cy: currentValuePoint.y,
    r: CURRENT_POINT_RADIUS,
    fill: whiteColor,
    stroke: accentColor,
    strokeWidth: 6,
    paintOrder: "stroke"
  }), /*#__PURE__*/React.createElement(Circle, {
    cx: maxValuePoint.x,
    cy: maxValuePoint.y,
    r: POINT_RADIUS,
    fill: pointsColor
  }), /*#__PURE__*/React.createElement(Circle, {
    cx: minValuePoint.x,
    cy: minValuePoint.y,
    r: POINT_RADIUS,
    fill: pointsColor
  }), /*#__PURE__*/React.createElement(Circle, {
    cx: averageValuePoint.x,
    cy: averageValuePoint.y,
    r: POINT_RADIUS,
    fill: accentColor
  }), /*#__PURE__*/React.createElement(FanChartCurrentValueLabel, {
    x: currentValueLabelPoint.x,
    y: currentValueLabelPoint.y,
    label: labelCurrent
  }), /*#__PURE__*/React.createElement(Group, {
    left: graphWidth - axisRightWidth,
    innerRef: axisRightRef
  }, /*#__PURE__*/React.createElement(Text, {
    y: maxLabelY,
    fill: textColor,
    fontSize: 12,
    fontFamily: theme.fonts["default"],
    verticalAnchor: "middle"
  }, labelMax), /*#__PURE__*/React.createElement(Text, {
    y: averageValuePoint.y,
    fill: accentColor,
    fontSize: 12,
    fontFamily: theme.fonts["default"],
    verticalAnchor: "middle"
  }, labelAverage), /*#__PURE__*/React.createElement(Text, {
    y: minLabelY,
    fill: textColor,
    fontSize: 12,
    fontFamily: theme.fonts["default"],
    verticalAnchor: "middle"
  }, labelMin))));
};