/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React, { useCallback, useMemo } from 'react';
import { LinearGradient } from '@visx/gradient';
import { ParentSizeModern } from '@visx/responsive';
import { scaleLinear } from '@visx/scale';
import { AreaClosed, Line, LinePath } from '@visx/shape';
import { max } from 'd3-array';
import styled, { useTheme } from 'styled-components';
import { AccessibleId, useAccessibleId } from "../AccessibleId";
import { Color } from "../../constants";
import { Relative } from "../Position";
import { themeColor } from "../../utils";
import { SIDE_OFFSET } from "./constants";
import { HorizontalAxis } from "./HorizontalAxis";
import { VerticalAxis } from "./VerticalAxis";
import { LineLabel } from "./LineLabel";
import { LineChartVariant } from "./variants";
import { getGraphHeight, getMargin } from "../BarChart/utils";
var GraphContainer = /*#__PURE__*/styled.svg.withConfig({
  displayName: "LineChart__GraphContainer",
  componentId: "whchrm-0"
})(function (_ref) {
  var left = _ref.left,
      top = _ref.top;
  return {
    position: 'absolute',
    left: left,
    top: top
  };
});
export var LineChart = function LineChart(_ref2) {
  var _ref2$variant = _ref2.variant,
      variant = _ref2$variant === void 0 ? LineChartVariant.LARGE : _ref2$variant,
      rest = _objectWithoutPropertiesLoose(_ref2, ["variant"]);

  return /*#__PURE__*/React.createElement(AccessibleId, null, /*#__PURE__*/React.createElement(ParentSizeModern, null, function (_ref3) {
    var width = _ref3.width;
    return /*#__PURE__*/React.createElement(LineChartInner, _extends({
      width: width,
      height: getGraphHeight(variant),
      variant: variant
    }, rest));
  }));
};

var LineChartInner = function LineChartInner(_ref4) {
  var variant = _ref4.variant,
      width = _ref4.width,
      height = _ref4.height,
      _ref4$color = _ref4.color,
      color = _ref4$color === void 0 ? Color.BLUE : _ref4$color,
      data = _ref4.data,
      _ref4$projectedData = _ref4.projectedData,
      projectedData = _ref4$projectedData === void 0 ? [] : _ref4$projectedData,
      lineValue = _ref4.lineValue,
      labelMin = _ref4.labelMin,
      labelMax = _ref4.labelMax,
      labelLine = _ref4.labelLine,
      rest = _objectWithoutPropertiesLoose(_ref4, ["variant", "width", "height", "color", "data", "projectedData", "lineValue", "labelMin", "labelMax", "labelLine"]);

  var accessibleId = useAccessibleId();
  var gradientId = "area-gradient-" + accessibleId;
  var projectedGradientId = "area-projected-gradient-" + accessibleId;
  var theme = useTheme();
  var accentColor = themeColor(color)({
    theme: theme
  });
  var projectedColor = themeColor(Color.GREY_TONE_20)({
    theme: theme
  });
  var lineColor = themeColor(Color.GREY_TONE_50)({
    theme: theme
  });
  var margins = getMargin(variant);
  var graphHeight = height - margins.top - margins.bottom + SIDE_OFFSET * 2;
  var graphWidth = width - margins.left - margins.right + SIDE_OFFSET * 2;
  var concatenatedData = useMemo(function () {
    return data.concat(projectedData);
  }, [data, projectedData]); // scales

  var xScale = useMemo(function () {
    return scaleLinear({
      range: [SIDE_OFFSET, graphWidth - SIDE_OFFSET],
      domain: [0, data.length - 1 + projectedData.length]
    });
  }, [graphWidth, data.length, projectedData.length]);
  var yScale = useMemo(function () {
    var _max;

    return scaleLinear({
      range: [graphHeight - SIDE_OFFSET, SIDE_OFFSET],
      domain: [0, (_max = max(concatenatedData, function (d) {
        return d.value;
      })) != null ? _max : 0]
    });
  }, [graphHeight, concatenatedData]);
  var projectedNormalizedData = useMemo(function () {
    return data && data.length ? [data[data.length - 1]].concat(projectedData) : projectedData;
  }, [data, projectedData]); // accessors

  var dataXAccessor = useCallback(function (_, index) {
    return xScale(index);
  }, [xScale]);
  var projectedDataXAccessor = useCallback(function (_, index) {
    return xScale(index + data.length - (data.length ? 1 : 0));
  }, [xScale, data.length]);
  var yAccessor = useCallback(function (d) {
    return yScale(d.value);
  }, [yScale]);
  var lineY = lineValue && yScale(lineValue);

  if (width === 0) {
    return null;
  }

  return /*#__PURE__*/React.createElement(Relative, _extends({
    maxWidth: width,
    height: height
  }, rest), /*#__PURE__*/React.createElement(GraphContainer, {
    width: graphWidth,
    height: graphHeight,
    left: margins.left - SIDE_OFFSET,
    top: margins.top - SIDE_OFFSET
  }, /*#__PURE__*/React.createElement(LinearGradient, {
    id: gradientId,
    from: accentColor,
    to: accentColor,
    fromOpacity: 0.5,
    toOpacity: 0
  }), /*#__PURE__*/React.createElement(LinearGradient, {
    id: projectedGradientId,
    from: projectedColor,
    to: projectedColor,
    fromOpacity: 0.5,
    toOpacity: 0
  }), /*#__PURE__*/React.createElement(AreaClosed, {
    data: data,
    x: dataXAccessor,
    y: yAccessor,
    yScale: yScale,
    fill: "url(#" + gradientId + ")"
  }), /*#__PURE__*/React.createElement(AreaClosed, {
    data: projectedNormalizedData,
    x: projectedDataXAccessor,
    y: yAccessor,
    yScale: yScale,
    fill: "url(#" + projectedGradientId + ")"
  }), /*#__PURE__*/React.createElement(LinePath, {
    data: data,
    stroke: accentColor,
    strokeWidth: 2,
    x: dataXAccessor,
    y: yAccessor
  }), /*#__PURE__*/React.createElement(LinePath, {
    data: projectedNormalizedData,
    stroke: projectedColor,
    strokeWidth: 2,
    x: projectedDataXAccessor,
    y: yAccessor,
    strokeDasharray: "3,6"
  }), lineY && /*#__PURE__*/React.createElement(Line, {
    from: {
      x: 0,
      y: lineY
    },
    to: {
      x: graphWidth,
      y: lineY
    },
    stroke: lineColor,
    strokeDasharray: "2,3"
  })), variant === LineChartVariant.LARGE && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(HorizontalAxis, {
    scale: xScale,
    data: concatenatedData
  }), /*#__PURE__*/React.createElement(VerticalAxis, {
    labelMin: labelMin,
    labelMax: labelMax
  }), lineY && labelLine && /*#__PURE__*/React.createElement(LineLabel, {
    top: lineY + margins.top,
    right: 0
  }, labelLine)));
};