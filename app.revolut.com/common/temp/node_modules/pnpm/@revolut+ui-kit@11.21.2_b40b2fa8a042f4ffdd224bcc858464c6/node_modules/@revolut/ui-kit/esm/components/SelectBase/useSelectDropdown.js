/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

var _KEY_DIRECTIONS;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useCallback, useRef } from 'react';
import { combine, getRefElement, noop, setRefs } from "../../utils";
import { useDocument, useFocusTrap } from "../../hooks";
import { KeyboardEventKey } from "../../constants";
var KEY_DIRECTIONS = (_KEY_DIRECTIONS = {}, _KEY_DIRECTIONS[KeyboardEventKey.ARROW_DOWN] = 1, _KEY_DIRECTIONS[KeyboardEventKey.ARROW_UP] = -1, _KEY_DIRECTIONS);
export function useSelectDropdown(_ref) {
  var _ref$onEscape = _ref.onEscape,
      onEscape = _ref$onEscape === void 0 ? noop : _ref$onEscape,
      focusRef = _ref.focusRef,
      _ref$focusTrap = _ref.focusTrap,
      focusTrap = _ref$focusTrap === void 0 ? false : _ref$focusTrap;
  var ref = useRef(null);
  var doc = useDocument();
  useFocusTrap(ref, focusTrap, {
    fallbackFocus: getRefElement(ref),
    initialFocus: focusRef ? getRefElement(focusRef) : undefined,
    returnFocusOnDeactivate: false
  });
  var handleKeydown = useCallback(function (event) {
    var _focusRef$current, _cells$last, _cells$next;

    if (!doc) return;

    switch (event.key) {
      case KeyboardEventKey.ARROW_UP:
      case KeyboardEventKey.ARROW_DOWN:
        {
          event.preventDefault();
          var cells = Array.from(event.currentTarget.querySelectorAll('[role=option]'));
          var index = cells.findIndex(function (cell) {
            return cell === doc.activeElement;
          });
          var last = cells.length - 1;
          var next = index + KEY_DIRECTIONS[event.key];

          switch (next) {
            case -1:
            case last + 1:
              focusRef == null ? void 0 : (_focusRef$current = focusRef.current) == null ? void 0 : _focusRef$current.focus();
              break;

            case -2:
              (_cells$last = cells[last]) == null ? void 0 : _cells$last.focus();
              break;

            default:
              (_cells$next = cells[next]) == null ? void 0 : _cells$next.focus();
          }

          break;
        }

      case KeyboardEventKey.ESCAPE:
        {
          onEscape();
          break;
        }
    }
  }, [doc, onEscape, focusRef]);
  var getProps = useCallback(function (props) {
    return _extends({}, props, {
      ref: setRefs(ref, props.ref),
      tabIndex: -1,
      onKeyDown: combine(handleKeydown, props.onKeyDown)
    });
  }, [ref, handleKeydown]);
  return getProps;
}