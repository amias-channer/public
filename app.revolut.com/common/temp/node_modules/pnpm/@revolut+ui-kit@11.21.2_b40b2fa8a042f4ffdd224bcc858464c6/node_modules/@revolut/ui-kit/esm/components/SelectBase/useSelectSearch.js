/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

import { useEffect, useState } from 'react';
import { matchSorter } from 'match-sorter';
import { useLatestRef } from "../../hooks";
import { SelectSearchState } from "./constants";

var defaultSearch = _async(function (input, options) {
  return matchSorter(options, input, {
    keys: ['label', 'keywords.*']
  });
});

export function useSelectSearch(options, search, timeout) {
  if (search === void 0) {
    search = defaultSearch;
  }

  if (timeout === void 0) {
    timeout = process.env.NODE_ENV === 'test' ? 0 : 200;
  }

  var searchRef = useLatestRef(search);

  var _useState = useState(''),
      input = _useState[0],
      setInput = _useState[1];

  var _useState2 = useState(SelectSearchState.IDLE),
      state = _useState2[0],
      setState = _useState2[1];

  var _useState3 = useState(null),
      result = _useState3[0],
      setResult = _useState3[1];

  useEffect(function () {
    var fn = searchRef.current;
    var trimmed = input.trim();

    if (trimmed === '') {
      setResult(null);
    } else if (fn && options.length > 0) {
      var isCancelled = false;
      var timerId = setTimeout(function () {
        setState(SelectSearchState.PENDING);
        Promise.resolve(fn(trimmed, options)).then(function (response) {
          if (!isCancelled) {
            setState(SelectSearchState.IDLE);
            setResult(response);
          }
        })["catch"](function (error) {
          if (!isCancelled) {
            console.error(error);
            setState(SelectSearchState.FAILED);
          }
        });
      }, timeout);
      return function () {
        clearTimeout(timerId);
        setState(function (prev) {
          return prev === SelectSearchState.PENDING ? SelectSearchState.IDLE : prev;
        });
        isCancelled = true;
      };
    }
  }, [searchRef, options, input, timeout]);
  return {
    input: input,
    state: state,
    result: result || options,
    setInput: setInput
  };
}