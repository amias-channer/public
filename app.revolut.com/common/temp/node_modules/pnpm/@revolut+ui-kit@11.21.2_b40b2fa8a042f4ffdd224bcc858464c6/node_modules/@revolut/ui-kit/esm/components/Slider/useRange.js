/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

import { useCallback, useMemo } from 'react';
import { clamp } from "../../utils";
import { useControlled } from "../../hooks";
import { STEP, THUMB_SIZE } from "./constants";

var normalize = function normalize(n, min, max, step, precision) {
  return toFixed(precision, Math.round(clamp(min, max, n) / step) * step);
};

var getPrecision = function getPrecision(step) {
  var digits = String(step).split('.')[1];
  return digits ? digits.length : 0;
};

var toFixed = function toFixed(precision, n) {
  return Number(n.toFixed(precision));
};

export var useRange = function useRange(_ref) {
  var valueMin = _ref.valueMin,
      valueMax = _ref.valueMax,
      defaultMin = _ref.defaultMin,
      defaultMax = _ref.defaultMax,
      _ref$limitMin = _ref.limitMin,
      limitMin = _ref$limitMin === void 0 ? 0 : _ref$limitMin,
      _ref$limitMax = _ref.limitMax,
      limitMax = _ref$limitMax === void 0 ? 1 : _ref$limitMax,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? STEP : _ref$step,
      onChange = _ref.onChange;
  var precision = useMemo(function () {
    return getPrecision(step);
  }, [step]);
  valueMin = valueMin === undefined ? valueMin : normalize(valueMin, limitMin, limitMax, step, precision);
  valueMax = valueMax === undefined ? valueMax : normalize(valueMax, valueMin || limitMin, limitMax, step, precision);
  defaultMin = valueMin === undefined ? defaultMin || limitMin : valueMin;
  defaultMax = valueMax === undefined ? defaultMax || limitMax : valueMax;

  var _useControlled = useControlled({
    defaultValue: defaultMin,
    value: valueMin
  }),
      min = _useControlled[0],
      setMin = _useControlled[1];

  var _useControlled2 = useControlled({
    defaultValue: defaultMax,
    value: valueMax
  }),
      max = _useControlled2[0],
      setMax = _useControlled2[1];

  var storeChanges = useCallback(function (minimum, maximum) {
    if (isNaN(minimum) || isNaN(maximum)) return;
    var normalizedMin = normalize(minimum, limitMin, max, step, precision);
    var normalizedMax = normalize(maximum, normalizedMin, limitMax, step, precision);
    setMin(valueMin === undefined ? normalizedMin : valueMin);
    setMax(valueMax === undefined ? normalizedMax : valueMax);
    onChange([normalizedMin, normalizedMax]);
  }, [limitMax, limitMin, max, onChange, precision, setMax, setMin, step, valueMax, valueMin]);
  var onChangeMin = useCallback(function (ev) {
    var _ev$target;

    return storeChanges(parseFloat(((_ev$target = ev.target) == null ? void 0 : _ev$target.value) || '0'), max);
  }, [max, storeChanges]);
  var onChangeMax = useCallback(function (ev) {
    var _ev$target2;

    return storeChanges(min, parseFloat(((_ev$target2 = ev.target) == null ? void 0 : _ev$target2.value) || '0'));
  }, [min, storeChanges]);
  var adjustLeft = useCallback(function (ev) {
    ev.stopPropagation();

    var _getBoundingClientRec = ev.target.getBoundingClientRect(),
        left = _getBoundingClientRec.left,
        width = _getBoundingClientRec.width;

    var x = ev.clientX - left - THUMB_SIZE / 2;
    storeChanges((min - limitMin) * (x / width) + limitMin, max);
  }, [min, max, storeChanges, limitMin]);
  var adjustRight = useCallback(function (ev) {
    ev.stopPropagation();

    var _getBoundingClientRec2 = ev.target.getBoundingClientRect(),
        left = _getBoundingClientRec2.left,
        width = _getBoundingClientRec2.width;

    var x = ev.clientX - left + THUMB_SIZE / 2;
    storeChanges(min, max + (limitMax - max) * (x / width));
  }, [min, max, storeChanges, limitMax]);
  var adjustMiddle = useCallback(function (ev) {
    ev.stopPropagation();

    var _getBoundingClientRec3 = ev.target.getBoundingClientRect(),
        left = _getBoundingClientRec3.left,
        width = _getBoundingClientRec3.width;

    var x = ev.clientX - left;
    var rate = x / width;

    if (rate < 0.5) {
      storeChanges(min + (max - min) * (x / width), max);
    } else {
      storeChanges(min, min + (max - min) * (x / width));
    }
  }, [min, max, storeChanges]);
  return {
    min: min,
    max: max,
    onChangeMin: onChangeMin,
    onChangeMax: onChangeMax,
    adjustLeft: adjustLeft,
    adjustMiddle: adjustMiddle,
    adjustRight: adjustRight
  };
};