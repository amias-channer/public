/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

var _TEXT_STYLE, _CellJustifyContent, _TextAlignMap;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import styled from 'styled-components';
import React, { forwardRef, useMemo } from 'react';
import { Space, TextStyle } from "../../constants";
import { Flex } from "../Flex";
import { CellAlign } from "./constants";
export var CellBaseType = {
  HEADER: 'header',
  BODY: 'body',
  CONTENT: 'content'
};
var TEXT_STYLE = (_TEXT_STYLE = {}, _TEXT_STYLE[CellBaseType.HEADER] = TextStyle.H6, _TEXT_STYLE[CellBaseType.BODY] = undefined, _TEXT_STYLE[CellBaseType.CONTENT] = undefined, _TEXT_STYLE);
var CellJustifyContent = (_CellJustifyContent = {}, _CellJustifyContent[CellAlign.START] = 'flex-start', _CellJustifyContent[CellAlign.CENTER] = 'center', _CellJustifyContent[CellAlign.END] = 'flex-end', _CellJustifyContent);
var TextAlignMap = (_TextAlignMap = {}, _TextAlignMap[CellAlign.START] = 'start', _TextAlignMap[CellAlign.CENTER] = 'center', _TextAlignMap[CellAlign.END] = 'end', _TextAlignMap);
var ForwardRefCellBase = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var type = _ref.type,
      _ref$align = _ref.align,
      align = _ref$align === void 0 ? CellAlign.START : _ref$align,
      rest = _objectWithoutPropertiesLoose(_ref, ["type", "align"]);

  var styles = useMemo(function () {
    var _ref2;

    return _ref2 = {
      width: '100%',
      height: '100%',
      alignItems: 'stretch',
      textAlign: TextAlignMap[align],
      paddingX: type === CellBaseType.CONTENT || type === CellBaseType.HEADER ? Space.S_16 : undefined
    }, _ref2[Main] = {
      justifyContent: CellJustifyContent[align]
    }, _ref2;
  }, [align, type]);
  return /*#__PURE__*/React.createElement(Flex, _extends({
    ref: ref,
    textStyle: TEXT_STYLE[type],
    __css: styles
  }, rest));
});
var Main = /*#__PURE__*/styled(Flex).withConfig({
  displayName: "CellBase__Main",
  componentId: "sc-17inuxb-0"
})({
  flex: '1 1 auto',
  minWidth: 0,
  order: 2,
  alignItems: 'center',
  '& > *': {
    minWidth: 0
  }
});

var Start = function Start(_ref3) {
  var children = _ref3.children;
  return children != null ? /*#__PURE__*/React.createElement(Flex, {
    mr: Space.S_8,
    alignItems: "center",
    order: 1
  }, children) : null;
};

var End = function End(_ref4) {
  var children = _ref4.children;
  return children != null ? /*#__PURE__*/React.createElement(Flex, {
    ml: Space.S_8,
    alignItems: "center",
    order: 3
  }, children) : null;
};

export var CellBase = Object.assign(ForwardRefCellBase, {
  Start: Start,
  Main: Main,
  End: End
});