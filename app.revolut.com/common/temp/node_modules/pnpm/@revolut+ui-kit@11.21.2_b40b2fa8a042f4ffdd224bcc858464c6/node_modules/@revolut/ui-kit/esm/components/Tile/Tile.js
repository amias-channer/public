/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React, { forwardRef, useMemo } from 'react';
import createSlots from 'nano-slots';
import * as Icons from '@revolut/icons';
import { Video } from "../Video";
import { Absolute } from "../Position";
import { TileVariant } from "./variants";
import { TileAction, TileAvatar, TileBody, TileButtonBase, TileContent, TileDescription, TileFooter, TileImage, TileLayout, TileSize, TileStatus, TileTitle, TileVideo } from "./styles";
import { Color, Space } from "../../constants";
import { getColorBrightness } from "../../utils";
import { AccessibleId } from "../AccessibleId";
import { getDescriptionId, getLabelId } from "./utils";
var FOOTER_SLOT = 'tile-footer-slot';
var TileSlotsContext = createSlots();

var useGetTextColor = function useGetTextColor(variant, color, bg) {
  return useMemo(function () {
    if (color) {
      return color;
    }

    if (variant === TileVariant.VOUCHER_SMALL && bg && typeof bg === 'string') {
      var brightness = getColorBrightness(bg);

      if (brightness === null) {
        return undefined;
      }

      return brightness > 125 ? Color.BLACK : Color.WHITE;
    }
  }, [color, variant, bg]);
};

var TileFooterFill = function TileFooterFill(props) {
  return /*#__PURE__*/React.createElement(TileSlotsContext.Fill, {
    name: FOOTER_SLOT
  }, /*#__PURE__*/React.createElement(TileFooter, props));
};

var TileMediaContent = function TileMediaContent(_ref) {
  var video = _ref.video,
      image = _ref.image,
      videoRef = _ref.videoRef,
      dropShadow = _ref.dropShadow;
  return /*#__PURE__*/React.createElement(React.Fragment, null, image ? /*#__PURE__*/React.createElement(TileImage, {
    image: image,
    dropShadow: dropShadow
  }) : video && /*#__PURE__*/React.createElement(TileVideo, {
    video: video,
    ref: videoRef,
    dropShadow: dropShadow
  }));
};

function getAspectRatio(variant, force) {
  var _TileSize$variant;

  if (force === void 0) {
    force = false;
  }

  if (variant === TileVariant.LARGE && !force) return null;
  return (_TileSize$variant = TileSize[variant]) == null ? void 0 : _TileSize$variant.aspectRatio;
}
/** @private  */


var TileBase = /*#__PURE__*/forwardRef(function (_ref2, ref) {
  var _ref2$variant = _ref2.variant,
      variant = _ref2$variant === void 0 ? TileVariant.LARGE : _ref2$variant,
      image = _ref2.image,
      children = _ref2.children,
      locked = _ref2.locked,
      video = _ref2.video,
      propsAspectRatio = _ref2.aspectRatio,
      preserveAspectRatio = _ref2.preserveAspectRatio,
      videoRef = _ref2.videoRef,
      colorProp = _ref2.color,
      bg = _ref2.bg,
      dropShadow = _ref2.dropShadow,
      rest = _objectWithoutPropertiesLoose(_ref2, ["variant", "image", "children", "locked", "video", "aspectRatio", "preserveAspectRatio", "videoRef", "color", "bg", "dropShadow"]);

  var aspectRatio = propsAspectRatio != null ? propsAspectRatio : getAspectRatio(variant, preserveAspectRatio);
  var color = useGetTextColor(variant, colorProp, bg);
  return /*#__PURE__*/React.createElement(TileSlotsContext.Provider, null, /*#__PURE__*/React.createElement(AccessibleId, null, function (_ref3) {
    var _TileSize$variant2;

    var id = _ref3.id;
    return /*#__PURE__*/React.createElement(TileButtonBase, _extends({
      ref: ref,
      variant: variant,
      locked: locked,
      color: color,
      bg: bg,
      "aria-labelledby": rest.role === 'presentation' ? undefined : getLabelId(id),
      "aria-describedby": rest.role === 'presentation' ? undefined : getDescriptionId(id),
      role: rest.use ? undefined : 'group'
    }, rest), /*#__PURE__*/React.createElement(TileBody, {
      image: variant === TileVariant.VOUCHER_SMALL ? undefined : image,
      aspectRatio: aspectRatio,
      height: aspectRatio == null ? (_TileSize$variant2 = TileSize[variant]) == null ? void 0 : _TileSize$variant2.height : null,
      locked: locked,
      bg: variant === TileVariant.VOUCHER_SMALL ? Color.BLACK_10 : undefined
    }, video && variant !== TileVariant.VOUCHER_SMALL && /*#__PURE__*/React.createElement(Video, {
      video: video,
      ref: videoRef
    }), /*#__PURE__*/React.createElement(TileLayout, {
      variant: variant
    }, variant === TileVariant.VOUCHER_SMALL && /*#__PURE__*/React.createElement(TileMediaContent, {
      image: image,
      video: video,
      videoRef: videoRef,
      dropShadow: dropShadow
    }), locked && /*#__PURE__*/React.createElement(Absolute, {
      top: Space.S_16,
      right: Space.S_16
    }, /*#__PURE__*/React.createElement(Icons.Lock, {
      color: Color.GREY_TONE_50,
      size: variant === TileVariant.VOUCHER_SMALL ? 16 : 24
    })), children)), /*#__PURE__*/React.createElement(TileSlotsContext.Slot, {
      name: FOOTER_SLOT
    }));
  }));
});
export var Tile = Object.assign(TileBase, {
  Avatar: TileAvatar,
  Action: TileAction,
  Description: TileDescription,
  Status: TileStatus,
  Footer: TileFooterFill,
  Title: TileTitle,
  Content: TileContent
});