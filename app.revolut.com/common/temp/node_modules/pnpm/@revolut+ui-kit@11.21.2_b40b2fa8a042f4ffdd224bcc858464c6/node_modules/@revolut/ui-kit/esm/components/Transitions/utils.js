/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import anime from 'animejs';
import * as RTG from 'react-transition-group';
import * as RTGTransition from 'react-transition-group/Transition';
import { Duration, Easing } from "../../constants";
import { DURATIONS, EASINGS } from "../../tokens/default";
import { noop } from "../../utils"; // we will trigger an event on the node after the exit animation completes
// to let the transitiongroup know that it can be removed from the DOM
// this is the only way to let react-transition-group delegate timing
// to the JavaScript animation
// From: https://github.com/aholachek/react-animation-comparison/blob/master/src/react-transition-group-anime-example.js

var ANIMATION_DONE_EVENT = 'animation::done';

var triggerAnimationDoneEvent = function triggerAnimationDoneEvent(node) {
  return node.dispatchEvent(new Event(ANIMATION_DONE_EVENT));
};

export var addAnimationEndListener = function addAnimationEndListener(node, done) {
  return node.addEventListener(ANIMATION_DONE_EVENT, function listener(event) {
    node.removeEventListener(ANIMATION_DONE_EVENT, listener);
    done(event);
  });
};
export var animate = function animate(_ref) {
  var _targets$ownerDocumen;

  var targets = _ref.targets,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? DURATIONS[Duration.MD] : _ref$duration,
      _ref$timing = _ref.timing,
      timing = _ref$timing === void 0 ? EASINGS[Easing.DEFAULT] : _ref$timing,
      _ref$easing = _ref.easing,
      easing = _ref$easing === void 0 ? "cubicBezier(" + timing + ")" : _ref$easing,
      _ref$complete = _ref.complete,
      _complete = _ref$complete === void 0 ? noop : _ref$complete,
      rest = _objectWithoutPropertiesLoose(_ref, ["targets", "duration", "timing", "easing", "complete"]);

  (_targets$ownerDocumen = targets.ownerDocument.defaultView) == null ? void 0 : _targets$ownerDocumen.requestAnimationFrame(function () {
    anime(_extends({
      targets: targets,
      duration: duration,
      easing: easing,
      complete: function complete(instance) {
        _complete(instance);

        if (targets) {
          triggerAnimationDoneEvent(targets);
        }
      }
    }, rest));
  });
};
export function isEntered(status) {
  return status === RTGTransition.ENTERED;
}
export function setTransitions(state) {
  var originalState = RTG.config.disabled;
  RTG.config.disabled = state === 'disabled';
  return function restore() {
    RTG.config.disabled = originalState;
  };
}
/** @deprecated Use `setTransitions` */

export var disableTransitions = function disableTransitions() {
  return setTransitions('disabled');
};