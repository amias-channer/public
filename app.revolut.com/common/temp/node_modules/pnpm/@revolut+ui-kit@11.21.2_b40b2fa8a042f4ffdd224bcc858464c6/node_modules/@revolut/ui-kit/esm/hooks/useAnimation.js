/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

var defaultLoadAnimation = _async(function (options) {
  return _invoke(function () {
    if (!lottie) {
      return _await(import('lottie-web/build/player/lottie_light'), function (_import) {
        lottie = _import["default"];
      });
    }
  }, function () {
    return lottie.loadAnimation(options);
  });
});

function _invoke(body, then) {
  var result = body();

  if (result && result.then) {
    return result.then(then);
  }

  return then(result);
}

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

import { useEffect, useRef, useState } from 'react';
import { noop, px } from "../utils";
var cache = new Map();

var defaultRequest = function defaultRequest(src) {
  return fetch(src).then(function (response) {
    return response.json();
  });
};

var lottie;
export function useAnimation(_ref) {
  var src = _ref.src,
      _ref$loop = _ref.loop,
      loop = _ref$loop === void 0 ? false : _ref$loop,
      _ref$autoPlay = _ref.autoPlay,
      autoPlay = _ref$autoPlay === void 0 ? true : _ref$autoPlay,
      _ref$autoSize = _ref.autoSize,
      autoSize = _ref$autoSize === void 0 ? false : _ref$autoSize,
      _ref$request = _ref.request,
      request = _ref$request === void 0 ? defaultRequest : _ref$request,
      _ref$loadAnimation = _ref.loadAnimation,
      loadAnimation = _ref$loadAnimation === void 0 ? defaultLoadAnimation : _ref$loadAnimation,
      _ref$cacheSize = _ref.cacheSize,
      cacheSize = _ref$cacheSize === void 0 ? 100 : _ref$cacheSize,
      _ref$onInstance = _ref.onInstance,
      onInstance = _ref$onInstance === void 0 ? noop : _ref$onInstance,
      _ref$onError = _ref.onError,
      onError = _ref$onError === void 0 ? noop : _ref$onError;
  var ref = useRef(null);

  var _useState = useState(null),
      animation = _useState[0],
      setAnimation = _useState[1];

  useEffect(function () {
    var run = _async(function () {
      if (container == null) {
        throw new Error('Please assign ref to element');
      }

      var animationData;
      return _invoke(function () {
        if (cache.has(src)) {
          animationData = cache.get(src);
        } else {
          return _await(request(src), function (_request) {
            animationData = _request;
            if (cache.size === cacheSize) cache.clear();
            cache.set(src, animationData);
          });
        }
      }, function () {
        if (isCancelled) {
          throw new Error('Loading cancelled');
        }

        return _await(loadAnimation({
          renderer: 'svg',
          container: container,
          loop: loop,
          autoplay: false,
          animationData: animationData
        }), function (_loadAnimation) {
          instance = _loadAnimation;

          if (autoSize) {
            container.style.width = px(animationData.w);
            container.style.height = px(animationData.h);
          }

          setAnimation(instance);
          return instance;
        });
      });
    });

    var container = ref.current;
    var instance = null;
    var isCancelled = false;
    run().then(onInstance, onError);
    return function () {
      var _instance;

      isCancelled = true;
      (_instance = instance) == null ? void 0 : _instance.destroy();
      setAnimation(null);

      if (autoSize && container) {
        container.style.width = '';
        container.style.height = '';
      }
    };
  }, [src, loop, autoSize, request, loadAnimation, cacheSize, onInstance, onError]);
  useEffect(function () {
    if (animation !== null && autoPlay) {
      animation.play();
    }
  }, [animation, autoPlay]);
  return ref;
}