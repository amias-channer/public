/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useCallback, useEffect, useRef, useState } from 'react';
import { combine, noop, setRefs } from "../utils";
import { useToggle } from '.';

/** @private */
export function useCheckbox(_ref) {
  var _ref$defaultIsActive = _ref.defaultIsActive,
      defaultIsActive = _ref$defaultIsActive === void 0 ? false : _ref$defaultIsActive,
      _ref$isIndeterminate = _ref.isIndeterminate,
      isIndeterminate = _ref$isIndeterminate === void 0 ? false : _ref$isIndeterminate,
      controlledActive = _ref.isActive,
      _ref$isDisabled = _ref.isDisabled,
      isDisabled = _ref$isDisabled === void 0 ? false : _ref$isDisabled,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? noop : _ref$onChange;
  var elementRef = useRef(null);

  var _useState = useState(false),
      isFocused = _useState[0],
      setFocused = _useState[1];

  var _useToggle = useToggle({
    defaultState: defaultIsActive,
    state: controlledActive,
    disabled: isDisabled
  }),
      isActive = _useToggle[0],
      toggle = _useToggle[1];

  useEffect(function () {
    if (elementRef.current !== null) {
      elementRef.current.indeterminate = isIndeterminate;
    }
  }, [isIndeterminate, elementRef]);
  var handleFocus = useCallback(function (event) {
    try {
      setFocused(event.target.matches(':focus-visible'));
    } catch (_) {
      setFocused(true);
    }
  }, []);
  var handleBlur = useCallback(function () {
    setFocused(false);
  }, []);
  var handleChange = useCallback(function (event) {
    if (isDisabled) {
      return;
    }

    toggle(event.target.checked);
    onChange(event);
  }, [isDisabled, onChange, toggle]);
  var state = {
    isActive: isActive,
    isIndeterminate: isIndeterminate,
    isDisabled: isDisabled,
    isFocused: isFocused
  };
  var getProps = useCallback(function (props) {
    return _extends({}, props, {
      ref: setRefs(elementRef, props.ref),
      checked: isActive,
      disabled: isDisabled,
      onChange: combine(handleChange, props.onChange),
      onFocus: combine(handleFocus, props.onFocus),
      onBlur: combine(handleBlur, props.onBlur)
    });
  }, [handleBlur, handleChange, handleFocus, isActive, isDisabled]);
  return [state, getProps];
}