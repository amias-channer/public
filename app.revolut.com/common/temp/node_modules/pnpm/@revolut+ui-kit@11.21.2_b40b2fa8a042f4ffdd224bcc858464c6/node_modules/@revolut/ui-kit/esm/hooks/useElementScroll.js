/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

import { useCallback, useEffect, useRef, useState } from 'react';
import { useLatestRef } from "./useLatestRef";
import { useWindow } from "./useWindow";
/** @private */

export var AlignVariant = {
  SIDE: 'side',
  CENTER: 'center'
};
/** @private */

var START_INDEX = 0;
var SCROLLING_TIMEOUT = 100;
var ScrollDirection;

(function (ScrollDirection) {
  ScrollDirection["Left"] = "left";
  ScrollDirection["Right"] = "right";
})(ScrollDirection || (ScrollDirection = {}));

function getPrevElement(list, win) {
  var sibling = list[0].previousElementSibling;

  if (sibling instanceof win.HTMLElement) {
    return sibling;
  }

  return null;
}

function getNextElement(list, win) {
  var sibling = list[list.length - 1].nextElementSibling;

  if (sibling instanceof win.HTMLElement && sibling.offsetParent !== null) {
    return sibling;
  }

  return null;
}

function getScrollDirectionByIndexAndSibling(children, prevElement, index) {
  if (prevElement) {
    var prevElementIndex = Array.from(children).findIndex(function (child) {
      return prevElement === child;
    });

    if (index <= prevElementIndex) {
      return ScrollDirection.Left;
    }
  }

  return ScrollDirection.Right;
}

function getChildrenLengthWithoutPlaceholder(children) {
  return children.length - 1;
}

/** @private */
export var useElementScroll = function useElementScroll(_ref) {
  var ref = _ref.ref,
      align = _ref.align,
      defaultIndex = _ref.defaultIndex,
      propIndex = _ref.index,
      onIndexChange = _ref.onIndexChange,
      placeholderRef = _ref.placeholderRef;

  var _useState = useState(null),
      prevElement = _useState[0],
      setPrevElement = _useState[1];

  var _useState2 = useState(null),
      nextElement = _useState2[0],
      setNextElement = _useState2[1];

  var prevElementRef = useLatestRef(prevElement);
  var eventTimeoutRef = useRef();
  var win = useWindow();
  useEffect(function () {
    var element = ref.current;

    if (element && win && win.ResizeObserver) {
      var update = function update() {
        var rect = element.getBoundingClientRect();
        var center = rect.left + rect.width / 2;
        var lastSelectedIndex = 0;
        var isLastChildElementInView = false;
        var visible = Array.from(element.children).filter(function (child) {
          return !placeholderRef || child !== placeholderRef.current;
        }).filter(function (child, index, array) {
          var childRect = child.getBoundingClientRect();
          var isElementInView = childRect.left <= center && childRect.right >= center || childRect.left >= rect.left && Math.floor(childRect.right) <= rect.right;
          isLastChildElementInView = isLastChildElementInView || isElementInView && index === array.length - 1;

          if (isElementInView) {
            lastSelectedIndex = index;
          }

          return isElementInView;
        });

        if (visible.length > 0) {
          setPrevElement(getPrevElement(visible, win));
          setNextElement(isLastChildElementInView ? null : getNextElement(visible, win));

          if (eventTimeoutRef.current) {
            clearTimeout(eventTimeoutRef.current);
          }

          eventTimeoutRef.current = setTimeout(function () {
            onIndexChange == null ? void 0 : onIndexChange(lastSelectedIndex);
          }, SCROLLING_TIMEOUT);
        }
      };

      update();
      element.addEventListener('scroll', update, {
        passive: true
      });
      var observer = new win.ResizeObserver(function (_ref2) {
        var entry = _ref2[0];

        if (entry.target instanceof win.HTMLElement) {
          update();
        }
      });
      observer.observe(element);
      return function () {
        setPrevElement(null);
        setNextElement(null);
        element.removeEventListener('scroll', update);
        observer.disconnect();
      };
    }
  }, [onIndexChange, ref, win, placeholderRef]);
  var scroll = useCallback(function (element, scrollDirection) {
    var currentNode = ref.current;
    if (!currentNode || !element) return;
    var newScrollPosition;

    switch (align) {
      case AlignVariant.SIDE:
        newScrollPosition = scrollDirection === ScrollDirection.Right ? element.offsetLeft : element.offsetLeft + element.getBoundingClientRect().width - currentNode.getBoundingClientRect().width;
        break;

      default:
        newScrollPosition = element.offsetLeft + element.getBoundingClientRect().width / 2 - currentNode.getBoundingClientRect().width / 2;
        break;
    }

    currentNode.scrollTo({
      left: newScrollPosition,
      behavior: 'smooth'
    });
  }, [ref, align]);
  var scrollRight = useCallback(function () {
    return scroll(nextElement, ScrollDirection.Right);
  }, [scroll, nextElement]);
  var scrollLeft = useCallback(function () {
    return scroll(prevElement, ScrollDirection.Left);
  }, [scroll, prevElement]);
  useEffect(function () {
    var carousel = ref.current;

    if (win && propIndex !== undefined && carousel && propIndex < getChildrenLengthWithoutPlaceholder(carousel.children)) {
      var destinationElement = carousel.children[propIndex];

      if (destinationElement instanceof win.HTMLElement) {
        var prevElementInstance = prevElementRef.current;

        if (prevElementInstance !== undefined) {
          if (eventTimeoutRef.current) {
            clearTimeout(eventTimeoutRef.current);
          }

          scroll(destinationElement, getScrollDirectionByIndexAndSibling(carousel.children, prevElementInstance, propIndex));
        }
      }
    }
  }, [prevElementRef, propIndex, ref, scroll, win]); // eslint-disable-next-line react-hooks/exhaustive-deps

  useEffect(function () {
    var _ref3;

    var carousel = ref.current;
    if (!carousel || !win) return;
    var destinationElement = carousel.children[(_ref3 = defaultIndex != null ? defaultIndex : propIndex) != null ? _ref3 : START_INDEX];

    if (destinationElement instanceof win.HTMLElement) {
      var newScrollPosition;

      switch (align) {
        case AlignVariant.SIDE:
          newScrollPosition = destinationElement.offsetLeft;
          break;

        default:
          newScrollPosition = destinationElement.offsetLeft + destinationElement.getBoundingClientRect().width / 2 - carousel.getBoundingClientRect().width / 2;
          break;
      }

      carousel.scrollLeft = newScrollPosition;
    } // Don't need propIndex here. Use it just as default value if defaultIndex is not passed
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [align, defaultIndex, ref, win]);
  return {
    hasMoreLeft: prevElement !== null,
    hasMoreRight: nextElement !== null,
    scrollLeft: scrollLeft,
    scrollRight: scrollRight
  };
};