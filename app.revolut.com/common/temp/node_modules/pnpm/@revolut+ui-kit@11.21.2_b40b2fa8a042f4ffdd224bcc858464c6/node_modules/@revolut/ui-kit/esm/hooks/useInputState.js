/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useCallback, useMemo, useReducer } from 'react';
import { useAutofillHack } from "./useAutofillHack";
var ActionType;

(function (ActionType) {
  ActionType["BLUR"] = "BLUR";
  ActionType["FOCUS"] = "FOCUS";
  ActionType["CHANGE"] = "CHANGE";
  ActionType["AUTOFILL_START"] = "AUTOFILL_START";
  ActionType["AUTOFILL_CANCEL"] = "AUTOFILL_CANCEL";
})(ActionType || (ActionType = {}));

function inputStateReducer(state, action) {
  switch (action.type) {
    case ActionType.BLUR:
      {
        return _extends({}, state, {
          isFocused: false
        });
      }

    case ActionType.FOCUS:
      {
        return _extends({}, state, {
          isFocused: true
        });
      }

    case ActionType.AUTOFILL_START:
      {
        return _extends({}, state, {
          isAutofilled: true
        });
      }

    case ActionType.AUTOFILL_CANCEL:
      {
        return _extends({}, state, {
          isAutofilled: false
        });
      }

    case ActionType.CHANGE:
      {
        if (state.isControlled) {
          return state;
        }

        return _extends({}, state, {
          value: action.payload
        });
      }

    default:
      {
        throw new Error('Not reachable');
      }
  }
}

export function formatValueToString(value) {
  if (typeof value === 'string') {
    return value;
  }

  if (typeof value === 'number') {
    return String(value);
  }

  return '';
}
export function useInputState(_ref) {
  var _ref$type = _ref.type,
      inputType = _ref$type === void 0 ? 'text' : _ref$type,
      _ref$format = _ref.format,
      format = _ref$format === void 0 ? formatValueToString : _ref$format,
      autoFocus = _ref.autoFocus,
      focused = _ref.focused,
      disabled = _ref.disabled,
      readOnly = _ref.readOnly,
      defaultValue = _ref.defaultValue,
      value = _ref.value,
      onChange = _ref.onChange,
      onFocus = _ref.onFocus,
      onBlur = _ref.onBlur;

  var _useReducer = useReducer(inputStateReducer, {
    isControlled: value !== undefined,
    isFocused: !!autoFocus,
    value: format(defaultValue),
    isAutofilled: false
  }),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  var autofillHackProps = useAutofillHack(useCallback(function () {
    return dispatch({
      type: ActionType.AUTOFILL_START
    });
  }, []), useCallback(function () {
    return dispatch({
      type: ActionType.AUTOFILL_CANCEL
    });
  }, []));
  var currentValue = state.isControlled ? value : state.value;
  var inputValue = format(currentValue);
  var handleChange = useCallback(function (event) {
    if (disabled) {
      return;
    }

    if (typeof onChange === 'function') onChange(event);
    dispatch({
      type: ActionType.CHANGE,
      payload: event.target.value
    });
  }, [disabled, onChange]);
  var handleFocus = useCallback(function (event) {
    if (typeof onFocus === 'function') onFocus(event);
    dispatch({
      type: ActionType.FOCUS
    });
  }, [onFocus, dispatch]);
  var handleBlur = useCallback(function (event) {
    if (typeof onBlur === 'function') onBlur(event);
    dispatch({
      type: ActionType.BLUR
    });
  }, [onBlur, dispatch]);
  return useMemo(function () {
    var hasValue = Boolean(inputValue) || state.isAutofilled;
    var isFocused = Boolean(focused) || inputType !== 'button' && state.isFocused;
    var isDisabled = Boolean(disabled);
    var isReadOnly = Boolean(readOnly);

    var focus = function focus() {
      return dispatch({
        type: ActionType.FOCUS
      });
    };

    var blur = function blur() {
      return dispatch({
        type: ActionType.BLUR
      });
    };

    var getProps = function getProps(_ref2) {
      var _ = _ref2.defaultValue,
          rest = _objectWithoutPropertiesLoose(_ref2, ["defaultValue"]);

      return _extends({}, rest, autofillHackProps, {
        type: inputType,
        value: inputValue,
        onChange: handleChange,
        onBlur: handleBlur,
        onFocus: handleFocus
      });
    };

    return [{
      hasValue: hasValue,
      isFocused: isFocused,
      isDisabled: isDisabled,
      isReadOnly: isReadOnly
    }, {
      focus: focus,
      blur: blur,
      getProps: getProps
    }];
  }, [inputType, inputValue, focused, state.isFocused, state.isAutofilled, disabled, readOnly, handleChange, handleBlur, handleFocus, autofillHackProps]);
}