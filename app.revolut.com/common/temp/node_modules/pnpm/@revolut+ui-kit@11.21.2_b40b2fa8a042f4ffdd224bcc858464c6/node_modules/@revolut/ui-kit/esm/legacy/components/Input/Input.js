/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

var _COMPONENTS;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import React, { forwardRef } from 'react';
import styled, { css } from 'styled-components';
import { width as widthProp } from 'styled-system';
import { Color, TextStyle } from "../../../constants";
import { renderNothing, themeColor, themeTextStyle } from "../../../utils";
import { autofillHackStyles, useLegacyInputState, useMessage } from "../../../hooks";
import { InputBase } from "../../../components/InputBase";
import { AccessibleId } from "../../../components/AccessibleId";
import { InputSize, InputVariant } from "./constants";
import { UnderlinedInputBox } from "./UnderlinedInputBox";
import { FilledInputBox } from "./FilledInputBox";
import { GreyInputBox } from "./GreyInputBox";
import { getDescriptionId, getLabelId } from "./utils";
var COMPONENTS = (_COMPONENTS = {}, _COMPONENTS[InputVariant.UNDERLINED] = UnderlinedInputBox, _COMPONENTS[InputVariant.FILLED] = FilledInputBox, _COMPONENTS[InputVariant.GREY] = GreyInputBox, _COMPONENTS);
var InputLabel = /*#__PURE__*/styled.label.withConfig({
  displayName: "Input__InputLabel",
  componentId: "sc-1gaz663-0"
})(["display:block;width:100%;color:", ";", " ", " ", ""], themeColor(Color.FOREGROUND), widthProp, themeTextStyle(TextStyle.INPUT), function (props) {
  return css(["cursor:", ";flex:", ";"], props.inputType === 'button' && !props.disabled ? 'pointer' : 'auto', props.width ? '0 0 auto' : null);
});
var AutofillInputBase = /*#__PURE__*/styled(InputBase).withConfig({
  displayName: "Input__AutofillInputBase",
  componentId: "sc-1gaz663-1"
})(["", " &&[type='button']{overflow:hidden;text-overflow:ellipsis;}"], autofillHackStyles);

function getMessageFromError(error) {
  if (typeof error === 'string') {
    return error;
  }

  if (error instanceof Error) {
    return error.message;
  }

  if ( /*#__PURE__*/React.isValidElement(error)) {
    return error;
  }

  return null;
}

var getInputPlaceholder = function getInputPlaceholder(variant, size, placeholder, nativePlaceholder) {
  if (variant === InputVariant.GREY) {
    return placeholder;
  }

  if (size !== InputSize.COMPACT) {
    return nativePlaceholder;
  }

  return placeholder;
};

var getInputAriaLabelledby = function getInputAriaLabelledby(id, variant, size, placeholder, label) {
  if (variant === InputVariant.GREY) {
    if (size !== InputSize.COMPACT) {
      return label ? getLabelId(id) : undefined;
    }
  } else if (size !== InputSize.COMPACT && placeholder) {
    return getLabelId(id);
  }

  return undefined;
};

export var Input = /*#__PURE__*/forwardRef(function (_ref, ref) {
  var className = _ref.className,
      innerRef = _ref.innerRef,
      _ref$border = _ref.border,
      border = _ref$border === void 0 ? true : _ref$border,
      placeholder = _ref.placeholder,
      placeholderProps = _ref.placeholderProps,
      label = _ref.label,
      labelProps = _ref.labelProps,
      _ref$renderAction = _ref.renderAction,
      renderAction = _ref$renderAction === void 0 ? renderNothing : _ref$renderAction,
      _ref$renderPrefix = _ref.renderPrefix,
      renderPrefix = _ref$renderPrefix === void 0 ? renderNothing : _ref$renderPrefix,
      error = _ref.error,
      _ref$hasError = _ref.hasError,
      hasError = _ref$hasError === void 0 ? Boolean(error) : _ref$hasError,
      _ref$message = _ref.message,
      message = _ref$message === void 0 ? getMessageFromError(error) : _ref$message,
      wrapper = _ref.wrapper,
      _ref$variant = _ref.variant,
      variant = _ref$variant === void 0 ? InputVariant.FILLED : _ref$variant,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? InputSize.DEFAULT : _ref$size,
      labelButtonClear = _ref.labelButtonClear,
      _ref$nativePlaceholde = _ref.nativePlaceholder,
      nativePlaceholder = _ref$nativePlaceholde === void 0 ? '' : _ref$nativePlaceholde,
      onClear = _ref.onClear,
      useIcon = _ref.useIcon,
      width = _ref.width,
      pending = _ref.pending,
      containerRef = _ref.containerRef,
      rest = _objectWithoutPropertiesLoose(_ref, ["className", "innerRef", "border", "placeholder", "placeholderProps", "label", "labelProps", "renderAction", "renderPrefix", "error", "hasError", "message", "wrapper", "variant", "size", "labelButtonClear", "nativePlaceholder", "onClear", "useIcon", "width", "pending", "containerRef"]);

  var m = useMessage();

  var _useLegacyInputState = useLegacyInputState(rest),
      inputState = _useLegacyInputState[0],
      inputActions = _useLegacyInputState[1];

  var inputProps = inputActions.getProps(rest);
  var Comp = COMPONENTS[variant];
  var inputPlaceholder = getInputPlaceholder(variant, size, placeholder, nativePlaceholder);
  return /*#__PURE__*/React.createElement(AccessibleId, null, function (_ref2) {
    var id = _ref2.id;
    return /*#__PURE__*/React.createElement(InputLabel, _extends({
      className: className,
      disabled: inputState.isDisabled,
      inputType: inputProps.type,
      width: width
    }, wrapper), /*#__PURE__*/React.createElement(Comp, _extends({
      size: size,
      hasError: hasError,
      border: border,
      placeholder: size === InputSize.COMPACT ? undefined : placeholder,
      placeholderProps: placeholderProps,
      label: label,
      labelProps: labelProps,
      hasPlaceholder: Boolean(inputPlaceholder),
      message: message,
      action: renderAction(_extends({
        state: inputState
      }, inputActions)),
      prefix: renderPrefix(_extends({
        state: inputState
      }, inputActions)),
      labelButtonClear: labelButtonClear != null ? labelButtonClear : m('action.clear'),
      onClear: onClear,
      useIcon: useIcon,
      isPending: pending,
      containerRef: containerRef
    }, inputState), /*#__PURE__*/React.createElement(AutofillInputBase, _extends({
      ref: innerRef || ref,
      placeholder: inputPlaceholder,
      "aria-labelledby": getInputAriaLabelledby(id, variant, size, placeholder, label),
      "aria-describedby": message ? getDescriptionId(id) : undefined
    }, inputProps))));
  });
});