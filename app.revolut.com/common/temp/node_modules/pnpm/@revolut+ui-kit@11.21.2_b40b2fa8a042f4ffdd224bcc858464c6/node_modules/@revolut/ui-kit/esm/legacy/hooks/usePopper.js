/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { useEffect, useRef } from 'react';
import PopperJS from 'popper.js';
import { noop } from "../../utils";

/** @deprecated This hook will be update in the next breaking release with incompatible API, please import from `Legacy` namespace or use `/legacy` entrypoint  */
export function usePopper(_ref) {
  var _ref$placement = _ref.placement,
      placement = _ref$placement === void 0 ? 'auto' : _ref$placement,
      _ref$fitInAnchor = _ref.fitInAnchor,
      fitInAnchor = _ref$fitInAnchor === void 0 ? false : _ref$fitInAnchor,
      _ref$preventOverflow = _ref.preventOverflow,
      preventOverflow = _ref$preventOverflow === void 0 ? true : _ref$preventOverflow,
      _ref$boundariesElemen = _ref.boundariesElement,
      boundariesElement = _ref$boundariesElemen === void 0 ? 'scrollParent' : _ref$boundariesElemen,
      _ref$flip = _ref.flip,
      flip = _ref$flip === void 0 ? true : _ref$flip,
      _ref$shift = _ref.shift,
      shift = _ref$shift === void 0 ? true : _ref$shift,
      modifiers = _ref.modifiers,
      _ref$positionFixed = _ref.positionFixed,
      positionFixed = _ref$positionFixed === void 0 ? false : _ref$positionFixed;
  var rootRef = useRef(null);
  var targetRef = useRef(null);
  var instanceRef = useRef(null);

  function destroy() {
    var _instanceRef$current;

    (_instanceRef$current = instanceRef.current) == null ? void 0 : _instanceRef$current.destroy();
    instanceRef.current = null;
  }

  useEffect(function () {
    var _instanceRef$current2;

    (_instanceRef$current2 = instanceRef.current) == null ? void 0 : _instanceRef$current2.update();
  });
  useEffect(function () {
    var rootElement = rootRef.current;
    var targetElement = targetRef.current;

    if (rootElement == null || targetElement == null) {
      return noop;
    }

    if (fitInAnchor) {
      var rect = targetElement.getBoundingClientRect();
      rootElement.style.width = "100%";
      rootElement.style.maxWidth = rect.width + "px";
    }

    destroy();
    instanceRef.current = new PopperJS(targetElement, rootElement, {
      placement: placement,
      positionFixed: positionFixed,
      modifiers: _extends({
        preventOverflow: _extends({}, Array.isArray(preventOverflow) ? {
          priority: preventOverflow
        } : {
          enabled: Boolean(preventOverflow)
        }, {
          boundariesElement: boundariesElement
        }),
        flip: {
          enabled: flip
        },
        shift: {
          enabled: shift
        },
        // When we disable `preventOverflow` we also need to disable `hide`
        // which enabled by default or we receive warning thrown by popper.js.
        // Only thing this option do is setting `x-out-of-boundaries` attribute in DOM
        // when element is "stuck" to side of screen with `preventOverflow`.
        //
        // You can override it with `modifiers` prop.
        //
        // https://popper.js.org/popper-documentation.html#modifiers..hide
        hide: {
          enabled: false
        }
      }, modifiers)
    });
    return function cleanup() {
      destroy();

      if (fitInAnchor) {
        rootElement.style.width = '';
        rootElement.style.maxWidth = '';
      }
    };
  }, [rootRef, targetRef, placement, positionFixed, modifiers, preventOverflow, boundariesElement, flip, shift, fitInAnchor]);
  return [rootRef, targetRef];
}