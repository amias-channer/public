/**
* Copyright 2018-present Revolut LTD
* 
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
* 
*     http://www.apache.org/licenses/LICENSE-2.0
* 
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* 
**/

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import { Children } from 'react';
import { parseToRgb, mix as unsafeMix, rgba as unsafeRgba } from 'polished';
import { css } from '@styled-system/css';
import { themeGet } from '@styled-system/theme-get';
import { DEFAULT_LOCALE } from "../constants";
export var keys = function keys(input) {
  return Object.keys(input);
};
export var values = function values(input) {
  return Object.values(input);
};
export var noop = function noop() {};
export var identity = function identity(value) {
  return value;
};
export var renderNothing = function renderNothing() {
  return null;
};
export var clamp = function clamp(min, max, input) {
  return Math.min(Math.max(input, min), max);
};
export var createChain = function createChain(separator) {
  return function () {
    for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
      parts[_key] = arguments[_key];
    }

    return Children.toArray(parts).reduce(function (acc, part, index) {
      if (index === 0) acc.push(part);else acc.push(separator, part);
      return acc;
    }, []);
  };
};
export var chain = createChain(' · ');
/**
 * Docs: {@link https://ui-kit.revolut.codes/utils/text-chain|textChain}
 */

export var textChain = function textChain() {
  return createChain(' · ').apply(void 0, arguments).join('');
};
/**
 * Docs: {@link https://ui-kit.revolut.codes/utils/range-chain|rangeChain}
 */

export var rangeChain = function rangeChain() {
  return createChain(' - ').apply(void 0, arguments).join('');
};
export var times = function times(fn, size) {
  return Array.from(Array(size).keys()).map(fn);
};
export var range = function range(from, to) {
  return times(identity, to).slice(from);
};
export var isBoolean = function isBoolean(value) {
  return typeof value === 'boolean';
};
export var isString = function isString(value) {
  return typeof value === 'string';
};
export var isReactText = function isReactText(value) {
  return isString(value) || isNumber(value);
};
export var isReactKey = function isReactKey(value) {
  return isReactText(value);
};
export var isNullable = function isNullable(value) {
  return value == null;
};
export var nonNullable = function nonNullable(value) {
  return !isNullable(value);
};
export var hasValue = function hasValue(value) {
  return !(isNullable(value) || Array.isArray(value) && value.length === 0);
};
export var isNumber = function isNumber(value) {
  return typeof value === 'number';
};
export var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
export var isObject = function isObject(value) {
  return typeof value === 'object' && value !== null;
};
export var isPlainObject = function isPlainObject(value) {
  return isObject(value) && !Array.isArray(value);
};
export var isTheme = function isTheme(theme) {
  return isObject(theme) && 'type' in theme;
};
export var isDefaultTheme = function isDefaultTheme(theme) {
  return isTheme(theme) && theme.type === 'default';
};
export var isUnifiedTheme = function isUnifiedTheme(theme) {
  return isTheme(theme) && theme.type === 'unified';
};
export function isColorModeTheme(theme) {
  return isObject(theme) && 'colorModes' in theme;
}
export function parseBoolean(input) {
  switch (input) {
    case 'true':
      return true;

    case 'false':
      return false;

    default:
      return input;
  }
}
export function isBreakpointTheme(theme) {
  return isObject(theme) && 'breakpoints' in theme;
}
export function hasColorMode(theme, mode) {
  return isColorModeTheme(theme) && mode in theme.colorModes;
}
export var px = function px(input) {
  return isNumber(input) ? input + "px" : input;
};
export var indexOf = function indexOf(value, input) {
  return Array.isArray(input) ? input.indexOf(value) : -1;
};
export function merge(a, b) {
  var target = _extends({}, a, b);

  return keys(target).reduce(function (acc, key) {
    var valueA = a[key];
    var valueB = b[key];

    if (isPlainObject(valueA) && isPlainObject(valueB)) {
      // TODO: Properly type deep merge, right now we are using shallow merge types (A & B)
      // In this example `acc[key]` expects type (A & B)[K], but get `A[K] & B[K]` instead
      // @ts-expect-error
      acc[key] = merge(valueA, valueB);
    }

    return acc;
  }, target);
}
export var themeVariant = function themeVariant(input) {
  return function (props) {
    var result = themeGet(input)(props);

    if (isString(result) || isFunction(result) || Array.isArray(result) || result == null) {
      return result;
    }

    return css(result)(props);
  };
};
export var themeColor = function themeColor(color, fallback) {
  return themeGet("colors." + color, fallback);
};
export var themeRadius = function themeRadius(radius, fallback) {
  return themeGet("radii." + radius, fallback);
};
export var themeSize = function themeSize(size, fallback) {
  return themeGet("sizes." + size, isNumber(fallback) || isString(fallback) ? px(fallback) : fallback);
};
export var themeSpace = function themeSpace(space, fallback) {
  return themeGet("space." + space, isNumber(fallback) || isString(fallback) ? px(fallback) : fallback);
};
export var themeTransition = function themeTransition(transition, fallback) {
  return themeGet("transitions." + transition, fallback);
};
export var themeTextStyle = function themeTextStyle(textStyle) {
  return themeVariant("textStyles." + textStyle);
};
export var themeFontSize = function themeFontSize(input) {
  return themeVariant("fontSizes." + input);
};
export var rgbaSafe = function rgbaSafe() {
  try {
    return unsafeRgba.apply(void 0, arguments);
  } catch (_) {
    return undefined;
  }
};
export var mixSafe = function mixSafe() {
  try {
    return unsafeMix.apply(void 0, arguments);
  } catch (_) {
    return undefined;
  }
};
export var toArray = function toArray(input) {
  if (input === void 0) {
    input = null;
  }

  if (Array.isArray(input)) {
    return input;
  }

  if (input !== null) {
    return [input];
  }

  return [];
};
export var findLastIndex = function findLastIndex(search, input) {
  return input.lastIndexOf(input.slice(0).reverse().find(search));
};
export var omitBy = function omitBy(fn) {
  return function (input) {
    if (input == null) {
      return null;
    }

    return keys(input).filter(function (key) {
      return fn(key);
    }).reduce(function (acc, key) {
      var _extends2;

      return _extends({}, acc, (_extends2 = {}, _extends2[key] = input[key], _extends2));
    }, {});
  };
};
export var omit = function omit(input, blacklist) {
  return omitBy(function (key) {
    return !blacklist.includes(key);
  })(input);
};
export var setRefs = function setRefs() {
  for (var _len2 = arguments.length, input = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    input[_key2] = arguments[_key2];
  }

  return function (value) {
    input.forEach(function (ref) {
      if (isFunction(ref)) {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
};
export var combine = function combine() {
  for (var _len3 = arguments.length, input = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    input[_key3] = arguments[_key3];
  }

  return function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return input.forEach(function (cb) {
      if (isFunction(cb)) cb.apply(void 0, args);
    });
  };
};

var parseUnit = function parseUnit(input) {
  return input.replace(/^([-\d.]+)(\D+)?$/, '$2').trim() || undefined;
};

export var getRefElement = function getRefElement(ref) {
  return function () {
    var element = ref.current;
    if (element == null) throw new Error("Can't get an element, please check passed ref");
    return element;
  };
};
/**
 * @example
 * const [ value, unit ] = splitUnit('30px') // → [ 30, 'px' ]
 */

export var splitUnit = function splitUnit(input) {
  return isString(input) ? [parseFloat(input), parseUnit(input)] : [input, undefined];
};
/** @deprecated */

export var isBase64 = function isBase64(input) {
  try {
    return btoa(atob(input)) === input;
  } catch (err) {
    return false;
  }
};
export function hash(input, arraySize, base) {
  if (base === void 0) {
    base = 59;
  }

  return input.split('').reduce(function (acc, _char) {
    return (acc * base + _char.charCodeAt(0)) % arraySize;
  }, 0);
}
export var getArrayElementFromString = function getArrayElementFromString(input, array) {
  if (input === void 0) {
    input = '';
  }

  return array[hash(input, array.length)];
}; // http://www.w3.org/TR/AERT#color-contrast

export var getColorBrightness = function getColorBrightness(hexColor) {
  try {
    var rgb = parseToRgb(hexColor);
    return Math.round((rgb.red * 299 + rgb.green * 587 + rgb.blue * 114) / 1000);
  } catch (err) {
    return null;
  }
};
export var getNodeChildren = function getNodeChildren(parent, win) {
  return Array.from(parent.children).filter(function (node) {
    return node instanceof win.HTMLElement;
  });
};

var getStyle = function getStyle(node, prop) {
  return getComputedStyle(node, null).getPropertyValue(prop);
};

var hasScroll = function hasScroll(node) {
  return /(auto|scroll|overlay)/.test(getStyle(node, 'overflow') + getStyle(node, 'overflow-y') + getStyle(node, 'overflow-x'));
};

export var getDocumentView = function getDocumentView(input) {
  if (input.defaultView === null) {
    throw new Error('Document should be attached to window');
  }

  return input.defaultView;
};
export var getDocumentViewSafe = function getDocumentViewSafe(input) {
  try {
    return input && getDocumentView(input);
  } catch (_) {
    return null;
  }
};
export var getView = function getView(input) {
  return getDocumentView('body' in input ? input : input.ownerDocument);
};
export function getScrollingParent(node, doc) {
  if (!node) return getGlobalScrollingElement(doc);
  if (hasScroll(node)) return node;
  return getScrollingParent(node.parentElement, doc);
}

function getScrollingParentsFor(element) {
  var parents = new Set();
  var current = getScrollingParent(element, element.ownerDocument);

  while (!parents.has(current)) {
    parents.add(current);
    current = getScrollingParent(current.parentElement, element.ownerDocument);
  }

  return parents;
}

export function preserveScrollPositionFor(element) {
  var parents = getScrollingParentsFor(element);
  var positions = new Map();

  for (var _iterator = _createForOfIteratorHelperLoose(parents), _step; !(_step = _iterator()).done;) {
    var parent = _step.value;
    positions.set(parent, {
      top: parent.scrollTop,
      left: parent.scrollLeft
    });
  }

  return function () {
    for (var _iterator2 = _createForOfIteratorHelperLoose(positions.entries()), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _step2.value,
          parent = _step2$value[0],
          position = _step2$value[1];
      parent.scrollTop = position.top;
      parent.scrollLeft = position.left;
    }
  };
}
export function getGlobalScrollingElement(doc) {
  var view = getDocumentView(doc);

  if (hasScroll(doc.body)) {
    return doc.body;
  }

  if (doc.scrollingElement instanceof view.HTMLElement) {
    return doc.scrollingElement;
  }

  return doc.documentElement;
}
export var getScrollEventTarget = function getScrollEventTarget(node) {
  return node === node.ownerDocument.documentElement || node === node.ownerDocument.body ? node.ownerDocument : node;
};
/**
 * Copy text to clipboard using native [Clipboard API](http://developer.mozilla.org/en-US/docs/Web/API/Clipboard) with [fallback](https://gist.github.com/lgarron/d1dee380f4ed9d825ca7) for older browsers
 * @url https://revolut.bitbucket.io/ui-kit/utils/copy-to-clipboard
 */

export var copyToClipboard = function copyToClipboard(input, doc) {
  if (doc === void 0) {
    doc = document;
  }

  return new Promise(function (resolve, reject) {
    if (navigator.clipboard) {
      navigator.clipboard.writeText(input).then(resolve, reject);
    } else {
      var _doc$getSelection, _doc$getSelection2;

      var hasCopied = false;
      var textRange = doc.createRange();
      textRange.selectNodeContents(doc.body);
      (_doc$getSelection = doc.getSelection()) == null ? void 0 : _doc$getSelection.addRange(textRange);

      var listener = function listener(event) {
        var _event$clipboardData;

        (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.setData('text/plain', input);
        event.preventDefault();
        hasCopied = true;
      };

      doc.addEventListener('copy', listener);
      doc.execCommand('copy');
      doc.removeEventListener('copy', listener);
      (_doc$getSelection2 = doc.getSelection()) == null ? void 0 : _doc$getSelection2.removeAllRanges();
      hasCopied ? resolve() : reject(new Error('Operation failed'));
    }
  });
};
export var wait = function wait(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
};
/** @private */

var PADDING_REGEX = /^((p[ltrbxy]?)$|padding)/;
export var hasPaddingProps = function hasPaddingProps(props) {
  return Object.keys(props).some(function (prop) {
    return PADDING_REGEX.test(prop);
  });
};
export var isAttached = function isAttached(element) {
  return element.ownerDocument.contains(element);
};
export var move = function move(source, start, end) {
  var item = source[start];
  var result = source.slice(0);
  result.splice(start, 1);
  result.splice(end, 0, item);
  return result;
};
export var abbreviate = function abbreviate(input, length) {
  if (length === void 0) {
    length = 2;
  }

  return input.trim().split(/\s+/).slice(0, length).map(function (part) {
    return part.slice(0, 1);
  }).join('').toUpperCase();
};
export function getSupportedLocale(locale, formatters) {
  if (formatters === void 0) {
    formatters = [Intl.DateTimeFormat, Intl.NumberFormat];
  }

  try {
    var locales = formatters.map(function (formatter) {
      return formatter.supportedLocalesOf(locale, {
        localeMatcher: 'lookup'
      });
    });

    if (locales.some(function (supported) {
      return supported.length === 0;
    })) {
      throw new Error('Locale not supported');
    }

    return locales[0][0];
  } catch (error) {
    if (process.env.NODE_ENV !== 'production') {
      console.warn("Passed locale (" + locale + ") is not supported. Switched to the default locale (" + DEFAULT_LOCALE + ")");
    }

    return DEFAULT_LOCALE;
  }
}
export var joinNumberFormatParts = function joinNumberFormatParts(parts) {
  return parts.map(function (part) {
    return part.value;
  }).join('');
};
export var filterNumberFormatCurrency = function filterNumberFormatCurrency(parts) {
  return parts.filter(function (_ref) {
    var type = _ref.type;
    return type !== 'currency';
  });
};
export var changeNumberFormatCurrencySymbol = function changeNumberFormatCurrencySymbol(parts, symbol) {
  return parts.map(function (part) {
    return part.type === 'currency' ? _extends({}, part, {
      value: symbol
    }) : part;
  });
};
var TEST_NUMBER = 1 / 3;
export var getNumberFractionDigits = function getNumberFractionDigits(locale, currency) {
  var _TEST_NUMBER$toLocale, _TEST_NUMBER$toLocale2;

  return (_TEST_NUMBER$toLocale = (_TEST_NUMBER$toLocale2 = TEST_NUMBER.toLocaleString(locale, currency ? {
    currency: currency,
    style: 'currency'
  } : {}).match(/3/g)) == null ? void 0 : _TEST_NUMBER$toLocale2.length) != null ? _TEST_NUMBER$toLocale : 0;
};