"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventEmitter = exports.addEventSubscription = exports.createSubscription = exports.getSubscriptionArguments = void 0;
function getSubscriptionArguments(eventName, params, callback) {
    if (typeof params === 'function') {
        return {
            eventName,
            callback: params
        };
    }
    return {
        eventName,
        callback,
        params
    };
}
exports.getSubscriptionArguments = getSubscriptionArguments;
function createSubscription(subscriptionProto, { params, callback }) {
    return Object.assign(Object.assign({}, subscriptionProto), { callback, 
        // IMPORTANT: Params object should contain ONLY JSON values: NOT functions, Date, RegExp, etc.
        paramsKey: params && JSON.stringify(params) });
}
exports.createSubscription = createSubscription;
function addEventSubscription(eventName, subscriptions, subscription) {
    const eventSubscriptions = subscriptions.get(eventName) || new Set();
    eventSubscriptions.add(subscription);
    subscriptions.set(eventName, eventSubscriptions);
    return function unsubscribe() {
        const eventSubscriptions = subscriptions.get(eventName);
        if (eventSubscriptions) {
            eventSubscriptions.delete(subscription);
            if (!eventSubscriptions.size) {
                subscriptions.delete(eventName);
            }
        }
        // @ts-ignore
        subscriptions = null;
        // @ts-ignore
        subscription = null;
    };
}
exports.addEventSubscription = addEventSubscription;
class EventEmitter {
    constructor() {
        this.subscriptions = new Map();
    }
    on(eventName, params, callback) {
        return addEventSubscription(eventName, this.subscriptions, createSubscription({}, getSubscriptionArguments(eventName, params, callback)));
    }
    once(eventName, params, callback) {
        return addEventSubscription(eventName, this.subscriptions, createSubscription({ once: true }, getSubscriptionArguments(eventName, params, callback)));
    }
    off(eventName, params, callback) {
        const { subscriptions } = this;
        const argumentsCount = arguments.length;
        // remove all subscriptions
        if (argumentsCount === 0 || eventName === undefined) {
            subscriptions.clear();
            return;
        }
        if (argumentsCount === 1) {
            subscriptions.delete(eventName);
            return;
        }
        const eventSubscriptions = subscriptions.get(eventName);
        if (!eventSubscriptions) {
            return;
        }
        const { callback: callbackToMatch, params: paramsArg } = getSubscriptionArguments(eventName, params, callback);
        const paramsKeyToMatch = paramsArg && JSON.stringify(paramsArg);
        eventSubscriptions.forEach((subscription, _, subscriptions) => {
            const matches = ((!callbackToMatch || subscription.callback === callbackToMatch) &&
                (!paramsKeyToMatch || subscription.paramsKey === paramsKeyToMatch));
            if (matches) {
                subscriptions.delete(subscription);
            }
        });
        if (!eventSubscriptions.size) {
            subscriptions.delete(eventName);
        }
    }
    emit(eventName, params, data) {
        const { subscriptions } = this;
        const eventSubscriptions = subscriptions.get(eventName);
        if (!eventSubscriptions) {
            return;
        }
        if (arguments.length < 3) {
            data = params;
            params = undefined;
        }
        const emitterEvent = { name: eventName };
        const paramsKeyToMatch = params && JSON.stringify(params);
        eventSubscriptions.forEach((subscription, _, subscriptions) => {
            const { callback, paramsKey } = subscription;
            if (!paramsKey || paramsKey === paramsKeyToMatch) {
                // remove if it's a one-time subscription
                if (subscription.once) {
                    subscriptions.delete(subscription);
                }
                if (typeof callback === 'function') {
                    // do not pass params to the callback which doesn't expect them
                    callback(emitterEvent, data);
                }
            }
        });
        if (!eventSubscriptions.size) {
            subscriptions.delete(eventName);
        }
    }
    getCallbacks(eventName, params) {
        const eventSubscriptions = this.subscriptions.get(eventName);
        if (!eventSubscriptions) {
            return [];
        }
        const callbacks = [];
        const paramsKeyToMatch = params && JSON.stringify(params);
        eventSubscriptions.forEach(({ paramsKey, callback }) => {
            const matches = (!paramsKeyToMatch || paramsKey === paramsKeyToMatch);
            if (matches && callback) {
                callbacks.push(callback);
            }
        });
        return callbacks;
    }
}
exports.EventEmitter = EventEmitter;
